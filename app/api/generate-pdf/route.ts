import { type NextRequest, NextResponse } from "next/server"
import { jsPDF } from "jspdf"

export async function POST(request: NextRequest) {
  try {
    const { book } = await request.json()

    if (!book) {
      return NextResponse.json({ error: "Book data is required" }, { status: 400 })
    }

    // Create new PDF document
    const doc = new jsPDF()
    const pageWidth = doc.internal.pageSize.getWidth()
    const margin = 20
    const maxWidth = pageWidth - 2 * margin
    let yPosition = margin

    // Title
    doc.setFontSize(20)
    doc.setFont("helvetica", "bold")
    const titleLines = doc.splitTextToSize(book.title, maxWidth)
    doc.text(titleLines, margin, yPosition)
    yPosition += titleLines.length * 10 + 10

    // Authors
    if (book.authors && book.authors.length > 0) {
      doc.setFontSize(14)
      doc.setFont("helvetica", "normal")
      doc.text(`By: ${book.authors.join(", ")}`, margin, yPosition)
      yPosition += 20
    }

    // Book details
    doc.setFontSize(12)
    doc.setFont("helvetica", "bold")
    doc.text("Book Details:", margin, yPosition)
    yPosition += 15

    doc.setFont("helvetica", "normal")

    if (book.publisher) {
      doc.text(`Publisher: ${book.publisher}`, margin, yPosition)
      yPosition += 10
    }

    if (book.publishedDate) {
      doc.text(`Published: ${book.publishedDate}`, margin, yPosition)
      yPosition += 10
    }

    if (book.pageCount > 0) {
      doc.text(`Pages: ${book.pageCount}`, margin, yPosition)
      yPosition += 10
    }

    if (book.language) {
      doc.text(`Language: ${book.language.toUpperCase()}`, margin, yPosition)
      yPosition += 10
    }

    if (book.categories && book.categories.length > 0) {
      doc.text(`Categories: ${book.categories.join(", ")}`, margin, yPosition)
      yPosition += 10
    }

    if (book.averageRating > 0) {
      doc.text(`Rating: ${book.averageRating.toFixed(1)}/5`, margin, yPosition)
      yPosition += 10
    }

    yPosition += 10

    // Description
    if (book.description) {
      doc.setFont("helvetica", "bold")
      doc.text("Description:", margin, yPosition)
      yPosition += 15

      doc.setFont("helvetica", "normal")
      // Remove HTML tags from description
      const cleanDescription = book.description.replace(/<[^>]*>/g, "")
      const descriptionLines = doc.splitTextToSize(cleanDescription, maxWidth)

      descriptionLines.forEach((line: string) => {
        if (yPosition > doc.internal.pageSize.getHeight() - margin) {
          doc.addPage()
          yPosition = margin
        }
        doc.text(line, margin, yPosition)
        yPosition += 7
      })
    }

    // Footer
    const pageCount = doc.getNumberOfPages()
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i)
      doc.setFontSize(10)
      doc.setFont("helvetica", "normal")
      doc.text(
        `Generated by Online Library - Page ${i} of ${pageCount}`,
        margin,
        doc.internal.pageSize.getHeight() - 10,
      )
    }

    // Generate PDF buffer
    const pdfBuffer = doc.output("arraybuffer")

    return new NextResponse(pdfBuffer, {
      headers: {
        "Content-Type": "application/pdf",
        "Content-Disposition": `attachment; filename="${book.title.replace(/[^a-z0-9]/gi, "_").toLowerCase()}.pdf"`,
      },
    })
  } catch (error) {
    console.error("Error generating PDF:", error)
    return NextResponse.json({ error: "Failed to generate PDF" }, { status: 500 })
  }
}
